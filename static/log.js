// Generated by LiveScript 1.5.0
(function(){
  "use strict";
  var $id, $q, after, every, timeIt, decompress, getStep, setProgress, progressTimer, runProgressTimer, updatePage, format02d, formatTime, postprocessPage, socket, retryEvery, retryCount, disconnect, connect;
  $id = function(it){
    return document.getElementById(it);
  };
  $q = function(it){
    return document.querySelector(it);
  };
  after = function(seconds, action){
    return setTimeout(action, seconds * 1000);
  };
  every = function(seconds, action){
    return setInterval(action, seconds * 1000);
  };
  timeIt = function(title, action){
    console.time(title);
    try {
      return action();
    } finally {
      console.timeEnd(title);
    }
  };
  decompress = window.TextDecoder != null
    ? function(data){
      return new TextDecoder().decode(pako.inflate(data));
    }
    : function(data){
      return pako.inflate(data, {
        to: 'string'
      });
    };
  getStep = function(){
    var e;
    try {
      return +/\d+/.exec($q('#m_fight_log .block_h .block_title').textContent)[0];
    } catch (e$) {
      e = e$;
      return 0;
    }
  };
  setProgress = function(value){
    try {
      $q('#turn_pbar .p_bar div').style.width = value + "%";
    } catch (e$) {}
  };
  progressTimer = null;
  runProgressTimer = function(ago, stepDuration){
    var percentsPerMillisecond, basePoint;
    percentsPerMillisecond = 0.1 / stepDuration;
    basePoint = Date.now();
    if (progressTimer != null) {
      clearInterval(progressTimer);
    }
    setProgress(Math.min(ago *= percentsPerMillisecond * 1000, 100));
    progressTimer = every(0.25, function(){
      var progress;
      if ((progress = ago + (Date.now() - basePoint) * percentsPerMillisecond) < 100 - 1e-5) {
        setProgress(progress);
      } else {
        setProgress(100);
        clearInterval(progressTimer);
        progressTimer = null;
      }
    });
  };
  updatePage = function(arg$){
    var allies, map, chronicle, wrapper, scrollValue;
    allies = arg$.allies, map = arg$.map, chronicle = arg$.chronicle;
    $id('alls').outerHTML = allies;
    wrapper = $id('map_wrap');
    scrollValue = wrapper.scrollLeft / wrapper.scrollWidth;
    $id('s_map').outerHTML = map;
    wrapper = $id('map_wrap');
    wrapper.scrollLeft = scrollValue * wrapper.scrollWidth;
    $id('m_fight_log').outerHTML = chronicle;
  };
  format02d = function(n){
    return ("0" + n).slice(-2);
  };
  formatTime = function(minutes){
    return format02d(Math.floor(minutes / 60)) + ":" + format02d(minutes % 60);
  };
  postprocessPage = function(){
    var offset, i$, ref$, len$, node, that, ref1$;
    offset = new Date().getTimezoneOffset();
    for (i$ = 0, len$ = (ref$ = document.getElementsByClassName('d_time')).length; i$ < len$; ++i$) {
      node = ref$[i$];
      if ((that = /(\d*)\s*:\s*(\d*)/.exec(node.textContent)) != null) {
        node.textContent = formatTime((((+that[1] * 60 + +that[2] - offset) % (ref1$ = 24 * 60) + ref1$) % ref1$));
      }
    }
  };
  socket = null;
  retryEvery = 3;
  retryCount = 0;
  disconnect = function(code){
    if (socket != null) {
      socket.onclose = null;
      socket.close(code);
      socket = null;
    }
  };
  connect = function(){
    var justConnected;
    if (socket != null) {
      console.log("An old socket still existed");
      disconnect();
    }
    socket = new WebSocket("" + (location.protocol === "https:" ? "wss" : "ws") + "://" + location.host + location.pathname + "/ws" + location.search + "");
    socket.onclose = function(){
      socket = null;
      after(3, connect);
    };
    justConnected = 1;
    socket.binaryType = 'arraybuffer';
    socket.onmessage = function(msg){
      var response, url;
      response = timeIt("Decompression", function(){
        return JSON.parse(decompress(msg.data));
      });
      if (response.stayHere) {
        disconnect();
        retryEvery = response.retryEvery, retryCount = response.retryCount;
        after(response.retryAfter, connect);
      } else if ((url = response.redirect) != null) {
        if (--retryCount > 0) {
          disconnect();
          after(retryEvery, connect);
        } else {
          location.replace(url);
        }
      } else if (response.step > getStep()) {
        console.timeEnd("New step");
        retryCount = 0;
        updatePage(response);
        postprocessPage();
        runProgressTimer(justConnected && response.ago, response.stepDuration);
        console.time("New step");
      }
      justConnected = 0;
    };
  };
  addEventListener('unload', function(){
    disconnect(1001);
  });
  addEventListener('DOMContentLoaded', function(){
    postprocessPage();
    runProgressTimer(gUpdatedAgo, gStepDuration);
    console.time("New step");
    connect();
  });
}).call(this);
