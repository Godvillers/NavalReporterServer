import std.array
import std.regex
import vibe.core.log
import geometry
import parsers


@safe:

private Appender!(char[ ]) _buffer, _distanceBuffer


static this() nothrow
    _buffer.reserve(150 << 10)
    _distanceBuffer.reserve(150)


private @property auto ref _rx(string pattern)() nothrow @nogc
    debug
        static rx = regex(pattern, "x")
    else
        static rx = ctRegex!(pattern, "x")
    return rx


private string _replace(string pattern, alias replacer)(string text)
    _buffer.clear()
    replaceAllInto!replacer(_buffer, text, _rx!pattern)
    return _buffer.data.idup


private void _process(alias text, alias init, alias exec, alias callback)() \
nothrow @trusted
    FsmState fsm
    fsm.p = text.ptr
    fsm.pe = text.ptr + text.length
    init(&fsm)
    _buffer.clear()
    while (fsm.p != fsm.pe)
        if (exec(&fsm) == Status.error)
            logError("Error while parsing HTML (" ~ __traits(identifier, text) ~ ')')
            return
        _buffer ~= fsm.skipped
        callback(fsm.branch, fsm.cap[ ])

    text = _buffer.data.idup


private HexCoord _rectToHex(double y, double x) nothrow pure @nogc
    import std.math

    enum scale = 1 / 19.05256

    const t = y * (sqrt(3.) / 3)
    const skew = t * (2 * scale)
    const horiz = (x - t) * scale
    return HexCoord(cast(int)lrint(skew), cast(int)lrint(horiz))


//Warning: Memory is reused across calls.
private char[ ] _formatDistanceMsg(in char[ ] prefix, int value) nothrow
    import std.conv
    import ru = l10n.russian

    _distanceBuffer.clear()
    _distanceBuffer ~= prefix
    _distanceBuffer ~= " ("
    _distanceBuffer ~= value.toChars()
    final switch (ru.getNumber(value)) with (ru.Number)
        case plural:   _distanceBuffer ~= " клеток)"; break
        case paucal:   _distanceBuffer ~= " клетки)"; break
        case singular: _distanceBuffer ~= " клетка)"; break
    return _distanceBuffer.data


struct DuelLog
    @safe:

    string host
    string id//\w{5,}
    int turn
    string allies, map, log//HTML.

    void process()
        import std.algorithm.searching
        import std.conv
        import std.datetime
        import std.format

        const start = Clock.currTime()

        scope(success)
            const end = Clock.currTime()
            logDiagnostic("Processed %s in %s ms", id, (end - start).total!"msecs")

        allies = allies._replace!(r"
            ▼ (?=</div> [\s\S]*? >\( ([^<]*?) \) (?:<a [^<>]*>➤</a>)? </span></div>)
        |   (?<=style=[^<>=]*? width: \s*) (\d\w+)
        |   (?<=style=[^<>=]*? font-size: \s*) (\d\w+) (?=[^<>]*> \s* [\d(])
        |   <span [^<>]*? class=[^<>=]*? \b[lr]_slot\b [^<>]*> [\s\S]*? </span>\s*</span>
        |   <a [^<>]*? class=[^<>=]*? \bpm_link\b [^<>]*>➤</a>
        |   (?<=>\s) \s+ (?=<)
        ", (c) {
            if (!c[1].empty)
                return `<a href="` ~ host ~ `/gods/` ~ c[1] ~ `" target="_blank">▶</a>`
            //TODO: Move this to the style sheet.
            if (!c[2].empty)
                return "175px"
            if (!c[3].empty)
                return "12px"
            return ""
        })

        double scale = 1
        if (const c = map.matchFirst(_rx!r"\bscale \s* \( \s* ([\d.]+)"))
            try
                scale = 1 / c[1].to!double
            catch (ConvException) { }

        char[21] numBuffer = void
        HexCoord hc
        map = map._replace!(r"
            (?<=\bheight[:=] \D?) \s* ([\d.]+)
        |   \bscale \s* \( \s* ([\d.]+)
        |   (?=\btranslate \s* \( \s* (-?[\d.]+) \s* , \s* (-?[\d.]+))
        |   (<title> [^<>]*?) \s? (?:\( [^<>()]*? \d [^<>()]* \))? \s* (?=</)
        |   \. (499|500)\d*\b
        |   (-?\d\.\d*e-\d{2,})
        |   (?<=\d) \.000\d*\b
        |   (\.\d\d)\d+\b
        |   <text [^<>]*> \s* </text>
        |   <line [^<]* </line>
        |   <div [^<>]*? dir_resp [^<]* </div>
        |   \s? \bd_overlay\b
        |   <span [^<>]*? class=[^<>=]*? \b[lr]_slot\b [^<>]*> [\s\S]*? </span>\s*</span>
        |   (?<=>\s) \s+ (?=<)
        ", (c) {
            if (!c[1].empty)
                try
                    return cast(const)numBuffer[ ].sformat("%.0f", c[1].to!double * scale)
                catch (ConvException)
                    return c[1]
            else if (!c[2].empty)
                return "scale(1"
            else if (!c[3].empty)
                try
                    hc = _rectToHex(c[4].to!double, c[3].to!double)
                catch (ConvException)
                    hc = HexCoord.init
            else if (!c[5].empty)
                if (hc == HexCoord.init)
                    return c[5]
                return _formatDistanceMsg(c[5].canFind("Рулить") ? "<title>" : c[5], hc.dist)
            else if (!c[6].empty)
                return ".5"
            else if (!c[7].empty)
                return "0"
            return c[8]
        })

        _process!(log, cParseLogInit, cParseLogExec, (br, c) { })


DuelLog duelLog(string link, int turn, string allies, string map, string log) pure
    import std.algorithm.searching
    import std.range
    import std.uri

    string host = "https://godville.net", id = "00000"
    const end = link.uriLength()
    if (end > 0)
        link = link[0 .. end - link[0 .. end].find('#').length]
        const firstSlash = link.length - link[8 .. $].find('/').length
        host = link[0 .. firstSlash]
        const lastSlash = firstSlash + link[firstSlash .. $].retro().find('/').retro().length
        id = link[lastSlash .. $]

    return DuelLog(host, id, turn, allies, map, log)
