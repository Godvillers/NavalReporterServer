import std.algorithm
import std.array
import std.typecons

import html

import u = preproc.utils


@system:

private Appender!(Node*[ ]) _queued

static this() nothrow @safe
    _queued.reserve(2048)


//Parse selectors at compile-time.
package static _s(string selector) = Selector.parse(selector)


package char[ ] _text(const(Node)* node) nothrow @safe \
in
    assert(node !is null)
do
    u._app.clear()
    node.text(u._app)
    return u._app.data


void queueDestroy(Node* node) \
in
    assert(node !is null)
do
    node.destroyChildren()
    _queued ~= node


void destroyQueued()
    _queued.data.each!q{a.destroy()}
    _queued.clear()


bool destroyIfDangerous(Node* node) \
in
    assert(node !is null)
do
    switch (node.tag)
        case \
            "applet", "audio", "bgsound", "embed", "frame", "iframe", "img", "input", "object",
            "script", "style", "video":
        queueDestroy(node)
        return true

        default: return false


void removeDangerousAttrs(Node* node) \
in
    assert(node !is null)
do
    foreach (name; node.attrs.byKey())
        if (name.startsWith("on") /+HTML event handlers.+/ || name.startsWith("data-vivaldi-"))
            node.removeAttr(name)


void removeEverythingDangerous(ref Document doc)
    import std.functional

    doc.elements.filter!(not!destroyIfDangerous).each!removeDangerousAttrs()


Node* findHeader(ref Document doc)
    return doc.querySelector(_s!".block_h")


void removeControlButtons(Node* header) \
in
    assert(header !is null)
do
    foreach (node; header.descendants)
        if (node.attr("class").splitter().canFind!(among!("l_slot", "r_slot")))
            //Do not destroy slot nodes themselves.
            node.destroyChildren()


void replaceDropDown(ref Document doc, Node* line, const(char)[ ] host, const(char)[ ] godName) \
in
    assert(line !is null)
do
    if (auto dropDown = doc.querySelector(_s!".opp_dropdown", line))
        dropDown.destroyChildren()
        auto link = doc.createElement("a", dropDown)
        link.attr("href", u.formatProfileLink(host, godName))
        link.attr("target", "_blank")
        link.appendText("â–¶")


void removeExtraWhitespace(ref Document doc)
    import std.range
    import std.uni
    import std.utf

    foreach (node; doc.nodes.filter!q{a.isTextNode})
        const s = _text(node)
        //If text is whitespace, only the first character should remain.
        if (s.startsWith("\r\n"))
            if (s.length > 2 && s[2 .. $].all!isWhite())
                node.text = "\r\n"
        else if (!s.empty)
            if (s[0] == ' ')
                //Common case; factored out to avoid allocations/copying.
                if (s.length > 1 && s[1 .. $].all!isWhite())
                    node.text = " "
            else
                const one = s.stride()
                if (s.length > one && s.all!isWhite())
                    const last = u._stableApp.data.length
                    u._stableApp ~= s[0 .. one]
                    node.text = u._stableApp.data[last .. $]


void updateTileTooltip(
    ref Document doc,
    Node* tile,
    double y,
    double x,
    double scale,
    Node* titleNode,
    const(u.Player)* player,
    const(char)[ ] cargo) \
in
    assert(tile !is null)
do
    import geometry

    const dist = HexCoord.fromRect(y, x, scale).dist
    const(char)[ ] oldMsg, tooltipText
    if (titleNode !is null)
        const s = _text(titleNode)
        //`s.count!(among!(...))` does not compile on 2.077.0. (?)
        if (player !is null && s.count!q{a == '[' || a == ']'} < 4)
            tooltipText = u.formatPlayerTooltip(*player, cargo, dist)
        else
            oldMsg = u.extractEssentialsFromTooltip(s)
    if (tooltipText.empty)
        tooltipText = u.formatDistanceTooltip(oldMsg, dist)

    if (titleNode !is null)
        titleNode.text = tooltipText
    else
        doc.createElement("title", tile).appendText(tooltipText)
