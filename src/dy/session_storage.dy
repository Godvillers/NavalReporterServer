import std.container.rbtree
import std.datetime

import vibe.core.sync

import duel_log


@safe:

struct Session
    @safe:

    enum Status: ubyte
        active,
        finished,
        outOfMemory,

    DuelLog log
    SysTime lastUpdated
    ManualEvent event
    Status status

    @disable this(this)//ManualEvent is non-copyable.

    @property long secondsSinceLastUpdated() const
        return (Clock.currTime() - lastUpdated).total!q{seconds}

    pragma(inline, true) \
    int opCmp()(auto ref const Session rhs) const nothrow pure /+@nogc+/
        import std.typecons

        //ID just for strict ordering in (rare) cases when timestamps match exactly.
        return tuple(lastUpdated, log.id).opCmp(tuple(rhs.lastUpdated, rhs.log.id))


enum SubmissionStatus: ubyte
    ignored,
    created,
    updated,


struct SessionStorage
    @safe:

    private
        RedBlackTree!(Session*, q{*a < *b}) _tree
        Session[string] _aa
        size_t _totalSpace, _maxMemory

    invariant
        assert(_tree.length == _aa.length)

    @disable this()
    @disable this(this)

    this(size_t maxMemory) nothrow pure \
    in
        assert(maxMemory > 0)
    body
        _tree = new typeof(_tree)
        _maxMemory = maxMemory

    @property size_t length() const nothrow pure @nogc
        return _aa.length

    inout(Session)* opBinaryRight(string op: "in")(const(char)[ ] logId) inout nothrow pure @nogc
        return logId in _aa

    SubmissionStatus submit(DuelLog log)
        import preproc

        if (auto session = log.id in _aa)
            if (log.step <= session.log.step)
                return SubmissionStatus.ignored

            _removeFromTree(session)
            _dropIfOutOfMemory()
            preprocessDuelLog(log)
            session.log = log
            session.lastUpdated = Clock.currTime()
            _insertIntoTree(session)

            session.event.emit()
            return SubmissionStatus.updated

        _dropIfOutOfMemory()
        preprocessDuelLog(log)
        _aa[log.id] = Session(log, Clock.currTime(), createManualEvent())
        _insertIntoTree(log.id in _aa)
        return SubmissionStatus.created

    void dropOldSessions(Duration maxAge)
        if (!_tree.empty)
            const thresholdPoint = Clock.currTime() - maxAge
            //The tree is sorted in such a way that older entries go first.
            while (!_tree.empty && _tree.front.lastUpdated <= thresholdPoint)
                _dropOldest(Session.Status.finished)

    private:

    void _insertIntoTree(Session* session) nothrow pure \
    in
        assert(session !is null)
    body
        const number = _tree.insert(session)
        assert(number == 1)
        _totalSpace += session.log.space

    void _removeFromTree(Session* session) nothrow pure \
    in
        assert(session !is null)
    body
        assert(_totalSpace >= session.log.space)
        _totalSpace -= session.log.space
        const number = _tree.removeKey(session)
        assert(number == 1)

    void _dropOldest(Session.Status status) \
    in
        assert(status != Session.Status.active)
    body
        auto session = _tree.front
        assert(session.status == Session.Status.active)
        session.status = status
        session.event.emit()
        assert(_totalSpace >= session.log.space)
        _totalSpace -= session.log.space
        _tree.removeFront()
        const existed = _aa.remove(session.log.id)
        assert(existed)

    void _dropIfOutOfMemory()
        while (_totalSpace >= _maxMemory)
            _dropOldest(Session.Status.outOfMemory)
