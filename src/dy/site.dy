import core.time
import std.algorithm
import std.array
import std.range

import vibe.data.json
import vibe.vibe

import duel_log
import session_storage
import zlib = zlib: ZlibException, ZlibTooLarge


private enum _expirationPeriod = 40.minutes


final class Site
    @safe:

    private SessionStorage _storage

    private static Appender!(ubyte[ ]) _ubyteApp

    static this() nothrow
        _ubyteApp.reserve(32_768)

    this(size_t maxMemory) nothrow pure
        _storage = SessionStorage(maxMemory)

    void postSend(string agent, string link, int turn, string cargo, string data) @system
        import std.base64

        const headerLength = agent.length + link.length + cargo.length
        if (headerLength > 256 || data.length > 60 << 10)
            logDiagnostic("Declined a request of %.1f KB", (headerLength + data.length) / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        const(void)[ ] decoded = data
        //Try to decode from Base64 first.
        _ubyteApp.clear()
        try
            Base64.decode(data, _ubyteApp)
            decoded = _ubyteApp.data
        catch (Base64Exception e)
            logDiagnostic("Base64 error: %s", e.msg)

        string concatenated
        try
            //A cast to `immutable(char)[ ]` is safe as `uncompress` allocates a new buffer.
            //We expect a compression ratio of about 20x-30x, so choose the buffer size accordingly.
            concatenated = cast(string)zlib.uncompress(decoded, 1 << 20, decoded.length << 5)
        catch (ZlibException e)
            logDiagnostic("Zlib decompression error: %s", e.msg)
            throw new HTTPStatusException(HTTPStatus.badRequest)
        catch (ZlibTooLarge)
            logDiagnostic("Declined a zip bomb of %.1f KB", data.length / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        logDiagnostic(
            "Decompressed %.1f KB -> %.1f KB (%.1fx)",
            decoded.length * (1. / 1024),
            concatenated.length * (1. / 1024),
            float(concatenated.length) / decoded.length)

        string[3] htmls//allies, map, chronicle
        concatenated.splitter("<&>").take(3).copy(htmls[ ])
        //Do actual work.
        const dLog = duelLog(link, turn, cargo, htmls[0], htmls[1], htmls[2])
        _storage.dropOldSessions(_expirationPeriod)
        final switch (_storage.submit(dLog)) with (SubmissionStatus)
            case updated: break
            case ignored: logDiagnostic("Ignoring duplicate %s", dLog.id); break
            case created: logInfo("Streaming %s with %s", dLog.id, agent); break

        //TODO: Check browser extension version.
        render!("send.dt", dLog)

    void get() @system
        render!"index.dt"

    void getDuels()
        import su = site_utils

        redirect(su.prefix)

    @path("/duels/log") \
    void getDuelsLogRoot()
        getDuels()

    @path("/duels/log/:id") \
    void getDuelsLog(string _id) @system
        _storage.dropOldSessions(_expirationPeriod)
        if (auto session = _id in _storage)
            const dLog = &session.dLog
            const ago = session.secondsSinceLastUpdated
            render!("log.dt", dLog, ago)
        else
            //The sailing has apparently ended, and there is no way to know
            //if it was hosted on godville.net or on godvillegame.com.
            redirect("https://godville.net/duels/log/" ~ _id)

    @path("/duels/log/:id/ws") \
    void getWS(string _id, scope WebSocket socket)
        auto response = Json.emptyObject
        auto app = appender!(char[ ])
        auto session = _id in _storage
        try
            do
                if (_id !in _storage || session.status == session_storage.Session.Status.finished)
                    const host = session !is null ? session.dLog.host : "https://godville.net"
                    app.clear()
                    app.writeJsonString(Json(["redirect": Json(host ~ "/duels/log/" ~ _id)]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    return
                const ago = session.secondsSinceLastUpdated
                if (session.status == session_storage.Session.Status.outOfMemory)
                    //We have to delete this log now, but we hope it will be resubmitted later.
                    app.clear()
                    app.writeJsonString(Json([
                        "stayHere":   Json(true),
                        "retryAfter": Json(max(20 - ago, 1)),
                        "retryEvery": Json(2),
                        "retryCount": Json(5),
                    ]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    return

                auto dLog = &session.dLog
                response["turn"] = dLog.turn
                response["ago"] = ago
                response["allies"] = dLog.allies
                response["map"] = dLog.map
                response["chronicle"] = dLog.chronicle

                app.clear()
                app.writeJsonString(response)
                const compressed = (() @trusted => zlib.compress(app.data))()
                logDiagnostic(
                    "Compressed %.1f KB -> %.1f KB (%.1fx)",
                    app.data.length * (1. / 1024),
                    compressed.length * (1. / 1024),
                    float(app.data.length) / compressed.length)

                socket.send(compressed)
                session.event.wait()
            while (socket.connected)
        catch (ZlibException e)
            logError("Zlib compression error: %s", e.msg)
