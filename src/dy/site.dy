import core.time
import std.algorithm
import std.array
import std.range

import vibe.data.json
import vibe.vibe

import duel_log
import session_storage
import zlib = zlib: ZlibException, ZlibTooLarge


private enum _expirationPeriod = 40.minutes


final class Site
    @safe:

    private SessionStorage _storage

    private static Appender!(ubyte[ ]) _ubyteApp//Used to decode a request when it is in Base64.

    static this() nothrow
        _ubyteApp.reserve(32_768)

    this(size_t maxMemory) nothrow pure
        _storage = SessionStorage(maxMemory)

    private void _emitBasicCORSHeaders()
        header("Access-Control-Allow-Origin", "*")

    void optionsSend()
        import std.conv

        enum oneDay = 24.hours.total!q{seconds}.to!string
        _emitBasicCORSHeaders()
        header("Access-Control-Allow-Methods", "OPTIONS, POST")
        header("Access-Control-Max-Age", oneDay)

    void postSend(string agent, string link, int turn, string cargo, string data) @system
        import std.base64

        const headerLength = agent.length + link.length + cargo.length
        if (headerLength > 256 || data.length > 60 << 10)
            logDiagnostic("Declined a request of %.1f KB", (headerLength + data.length) / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        const(void)[ ] decoded = data
        //Try to decode from Base64 first.
        _ubyteApp.clear()
        try
            Base64.decode(data, _ubyteApp)
            decoded = _ubyteApp.data
        catch (Base64Exception e)
            logDiagnostic("Base64 error: %s", e.msg)

        string concatenated
        try
            //A cast to `immutable(char)[ ]` is safe as `uncompress` allocates a new buffer.
            //We expect a compression ratio of about 20x-30x, so choose the buffer size accordingly.
            concatenated = cast(string)zlib.uncompress(decoded, 1 << 20, decoded.length << 5)
        catch (ZlibException e)
            logDiagnostic("Zlib decompression error: %s", e.msg)
            throw new HTTPStatusException(HTTPStatus.badRequest)
        catch (ZlibTooLarge)
            logDiagnostic("Declined a zip bomb of %.1f KB", data.length / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        logDiagnostic(
            "Decompressed %.1f KB -> %.1f KB (%.1fx)",
            decoded.length * (1. / 1024),
            concatenated.length * (1. / 1024),
            float(concatenated.length) / decoded.length)

        string[3] htmls//allies, map, chronicle
        concatenated.splitter("<&>").take(3).copy(htmls[ ])
        //Do actual work.
        const log = duelLog(link, turn, 20, 11, cargo, htmls[0], htmls[1], htmls[2])
        _storage.dropOldSessions(_expirationPeriod)
        final switch (_storage.submit(log)) with (SubmissionStatus)
            case updated: break
            case ignored: logDiagnostic("Ignoring duplicate %s", log.id); break
            case created: logInfo("Streaming %s with %s", log.id, agent); break

        //TODO: Check browser extension version.
        _emitBasicCORSHeaders()
        render!("send.dt", log)

    void get() @system
        render!"index.dt"

    void getDuels()
        import su = site_utils

        redirect(su.prefix)

    @path("/duels/log") \
    void getDuelsLogRoot()
        getDuels()

    @path("/duels/log/:id") \
    void getDuelsLog(string _id) @system
        _storage.dropOldSessions(_expirationPeriod)
        if (auto session = _id in _storage)
            const log = &session.log
            const ago = session.secondsSinceLastUpdated
            render!("log.dt", log, ago)
        else
            //The sailing has apparently ended, and there is no way to know
            //if it was hosted on godville.net or on godvillegame.com.
            redirect("https://godville.net/duels/log/" ~ _id)

    @path("/duels/log/:id/ws") \
    void getWS(string _id, scope WebSocket socket)
        auto response = Json.emptyObject
        auto app = appender!(char[ ])
        auto session = _id in _storage
        try
            do
                if (_id !in _storage || session.status == session_storage.Session.Status.finished)
                    const host = session !is null ? session.log.host : "https://godville.net"
                    app.clear()
                    app.writeJsonString(Json(["redirect": Json(host ~ "/duels/log/" ~ _id)]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    return

                auto log = &session.log
                const ago = session.secondsSinceLastUpdated
                if (session.status == session_storage.Session.Status.outOfMemory)
                    logInfo("Out of memory; dropping %s at step %d", log.id, log.step)
                    //We have to delete this log now, but we hope it will be resubmitted later.
                    app.clear()
                    app.writeJsonString(Json([
                        "stayHere":   Json(true),
                        "retryAfter": Json(max(20 - ago, 1)),
                        "retryEvery": Json(2),
                        "retryCount": Json(5),
                    ]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    return

                response["step"] = log.step
                response["ago"] = ago
                response["stepDuration"] = log.stepDuration
                response["allies"] = log.allies
                response["map"] = log.map
                response["chronicle"] = log.chronicle

                app.clear()
                app.writeJsonString(response)
                const compressed = (() @trusted => zlib.compress(app.data))()
                logDiagnostic(
                    "Compressed %.1f KB -> %.1f KB (%.1fx)",
                    app.data.length * (1. / 1024),
                    compressed.length * (1. / 1024),
                    float(app.data.length) / compressed.length)

                socket.send(compressed)
                session.event.wait()
            while (socket.connected)
        catch (ZlibException e)
            logError("Zlib compression error: %s", e.msg)
