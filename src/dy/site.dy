import core.time
import std.algorithm
import std.array
import std.conv
import std.range

import vibe.data.json
import vibe.vibe

import duel_log
import session_storage
import zlib = zlib: ZlibException, ZlibTooLarge


@safe:

private enum _expirationPeriod = 40.minutes


private struct _StepUploadRequest
    string agent
    string link
    float  stepDuration
    float  scale = 0//Zero means "auto-detect".
    int    step
    int    playerIndex
    string cargo
    string data


private void _httpEnforce(HTTPStatus status, string msg)
    throw new HTTPStatusException(status, msg)


private void _httpEnforce(string msg)
    _httpEnforce(HTTPStatus.badRequest, msg)


private void _httpEnforce(bool condition, lazy string msg)
    if (!condition)
        _httpEnforce(msg)


private T _load(T = string, Dict)(auto ref const Dict dict, string field)
    const p = field in dict
    _httpEnforce(p !is null, "Missing field '" ~ field ~ '\'')
    try
        return (*p).to!T
    catch (ConvException)
        _httpEnforce("Field '" ~ field ~ "' has an invalid value")
        assert(false)


private _StepUploadRequest _parseRequest(scope HTTPServerRequest req)
    import std.exception

    const f = req.form
    const v = f.get("protocolVersion").to!int.ifThrown!ConvException(0)
    if (v < 1 || v > 2)
        _httpEnforce(HTTPStatus.notImplemented, "Unsupported protocol version")

    _StepUploadRequest r = {
        agent:        f._load("agent"),
        link:         f._load("link"),
        stepDuration: f._load!float("stepDuration"),
        step:         f._load!int("step"),
        cargo:        f._load("cargo"),
        data:         f._load("data"),
    };
    final switch (v)
        case 1:
            r.scale       = f._load!float("scale")
            r.playerIndex = f._load!int("playerIndex") - 1
            _httpEnforce(r.scale >= 1e-6f, "'scale' must be positive")
            break

        case 2:
            r.playerIndex = f._load!int("playerNumber") - 1
            break

    //Be careful to handle NaNs.
    _httpEnforce(r.stepDuration >= 1e-6f, "'stepDuration' must be positive")
    _httpEnforce(r.step > 0, "'step' must be positive")
    //Note: (int.max + 1 >= 0) == false.
    _httpEnforce(r.playerIndex + 1 >= 0, "'playerNumber' must be non-negative")
    return r


final class Site
    @safe:

    private SessionStorage _storage

    private static Appender!(ubyte[ ]) _ubyteApp//Used to decode a request when it is in Base64.

    static this() nothrow
        _ubyteApp.reserve(32_768)

    this(size_t maxMemory) nothrow pure
        _storage = SessionStorage(maxMemory)

    private void _emitBasicCORSHeaders()
        header("Access-Control-Allow-Origin", "*")

    //vibe.d does not auto-generate an OPTIONS handler from a method name (?!).
    @method(HTTPMethod.OPTIONS) \
    @path("/send") \
    void optionsSend(scope HTTPServerResponse res)
        enum oneDay = 24.hours.total!q{seconds}.to!string
        _emitBasicCORSHeaders()
        header("Access-Control-Allow-Methods", "OPTIONS, POST")
        header("Access-Control-Max-Age", oneDay)
        res.writeVoidBody()//Otherwise, 404 is emitted.

    void postSend(scope HTTPServerRequest req) @system
        import std.base64

        const r = _parseRequest(req)
        const headerLength = r.agent.length + r.link.length + r.cargo.length
        if (headerLength > 256 || r.data.length > 60 << 10)
            logDiagnostic("Declined a request of %.1f KB", (headerLength + r.data.length) / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        const(void)[ ] decoded = r.data
        //Try to decode from Base64 first.
        _ubyteApp.clear()
        try
            Base64.decode(r.data, _ubyteApp)
            decoded = _ubyteApp.data
        catch (Base64Exception e)
            logDiagnostic("Base64 error: %s", e.msg)

        string concatenated
        try
            //A cast to `immutable(char)[ ]` is safe as `uncompress` allocates a new buffer.
            //We expect a compression ratio of about 20x-30x, so choose the buffer size accordingly.
            concatenated = cast(string)zlib.uncompress(decoded, 1 << 20, decoded.length << 5)
        catch (ZlibException e)
            logDiagnostic("Zlib decompression error: %s", e.msg)
            throw new HTTPStatusException(HTTPStatus.badRequest)
        catch (ZlibTooLarge)
            logDiagnostic("Declined a zip bomb of %.1f KB", r.data.length / 1024.)
            throw new HTTPStatusException(HTTPStatus.requestEntityTooLarge)

        logDiagnostic(
            "Decompressed %.1f KB -> %.1f KB (%.1fx)",
            decoded.length * (1. / 1024),
            concatenated.length * (1. / 1024),
            float(concatenated.length) / decoded.length)

        string[3] htmls//allies, map, chronicle
        concatenated.splitter("<&>").take(3).copy(htmls[ ])
        //Do actual work.
        const log = duelLog(
            r.link, r.step, r.playerIndex, r.stepDuration, r.scale, r.cargo,
            htmls[0], htmls[1], htmls[2],
        )
        _storage.dropOldSessions(_expirationPeriod)
        final switch (_storage.submit(log)) with (SubmissionStatus)
            case updated: break
            case ignored: logDiagnostic("Ignoring duplicate %s", log.id); break
            case created: logInfo("Streaming %s with %s", log.id, r.agent); break

        //TODO: Check browser extension version.
        _emitBasicCORSHeaders()
        render!("send.dt", log)

    void get() @system
        render!"index.dt"

    void getDuels()
        import su = site_utils

        redirect(su.prefix)

    @path("/duels/log") \
    void getDuelsLogRoot()
        getDuels()

    @path("/duels/log/:id") \
    void getDuelsLog(string _id) @system
        _storage.dropOldSessions(_expirationPeriod)
        if (auto session = _id in _storage)
            const log = &session.log
            const ago = session.secondsSinceLastUpdated
            render!("log.dt", log, ago)
        else
            //The sailing has apparently ended, and there is no way to know
            //if it was hosted on godville.net or on godvillegame.com.
            redirect("https://godville.net/duels/log/" ~ _id)

    @path("/duels/log/:id/ws") \
    void getWS(string _id, scope WebSocket socket) nothrow
        auto app = appender!(char[ ])
        auto session = _id in _storage
        try
            scope(failure) socket.close(1011)//Internal Error
            auto response = Json.emptyObject
            do
                if (_id !in _storage || session.status == session_storage.Session.Status.finished)
                    const host = session !is null ? session.log.host : "https://godville.net"
                    app.clear()
                    app.writeJsonString(Json(["redirect": Json(host ~ "/duels/log/" ~ _id)]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    return

                auto log = &session.log
                const ago = session.secondsSinceLastUpdated
                if (session.status == session_storage.Session.Status.outOfMemory)
                    logInfo("Out of memory; dropping %s at step %d", log.id, log.step)
                    //We have to delete this log now, but we hope it will be resubmitted later.
                    app.clear()
                    app.writeJsonString(Json([
                        "stayHere":   Json(true),
                        "retryAfter": Json(max(log.stepDuration - ago, 1)),
                        "retryEvery": Json(2),
                        "retryCount": Json(5),
                    ]))
                    socket.send((() @trusted => zlib.compress(app.data, 0))())
                    socket.close(1013)//Try Again Later
                    return

                response["step"] = log.step
                response["ago"] = ago
                response["stepDuration"] = log.stepDuration
                response["allies"] = log.allies
                response["map"] = log.map
                response["chronicle"] = log.chronicle

                app.clear()
                app.writeJsonString(response)
                const compressed = (() @trusted => zlib.compress(app.data))()
                logDiagnostic(
                    "Compressed %.1f KB -> %.1f KB (%.1fx)",
                    app.data.length * (1. / 1024),
                    compressed.length * (1. / 1024),
                    float(app.data.length) / compressed.length)

                socket.send(compressed)
                session.event.wait()
            while (socket.connected)
        catch (ZlibException e)
            logError("Zlib compression error: %s", e.msg)
        catch (Exception e)
            logError("Unexpected exception during WebSocket handling: %s", e.msg)
